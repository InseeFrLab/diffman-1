---
title: "Diffman tutorial"
author: "Clément G"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
    toc: true
    toc_depth: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r warning=FALSE,message=FALSE,echo = FALSE}
paquets <- c("data.table","btb","remotes","sf","igraph","Matrix","leaflet","dplyr","prettydoc","devtools","testthat")
# install.packages(paquets)
p <- lapply(paquets, function(p) suppressPackageStartupMessages(library(p, character.only = TRUE)))
# remotes::install_github("https://github.com/InseeFrLab/diffman-1")
```
## What can you do with diffman ?

```{r}

### Ce code sera amené à disparaitre, en fire une vignette ! ou bien un rmd !!!
#### Test sur données réelles 
data_rp <- data.table(readRDS("ext_data/data_rp.rds"))
compo <- return_connected_components(data_rp)
compo[,.(nb_com = length(z1)),by ="id_comp"][rev(order(nb_com)),]
```

Here the R session explodes if  we put the whole data.frame in entry so we can work component by component thanks to the last function. the bigger contains more than 18000 municipalities !!
Here we will tests with id_comp 1232 !

```{r}
list_z1_compo <- compo[id_comp == 329]$z1
input_dt <- data_rp[z1 %in% list_z1_compo]

l_area_z1_at_risk <- find_pbm_diff_tab(input_dt = input_dt,threshold = 11 )
length(l_area_z1_at_risk)

head(l_area_z1_at_risk,8)
```

299 union of elements of z1 at risk of differenciation here. let's look further one this risk area
```{r}
#lapply(l_area_z1_at_risk,length)
area_z1_at_risk <- l_area_z1_at_risk[[14]]
area_z1_at_risk

```

The return diff info function allows us to know ex&actly where the differencing issue occurs (which intersection square miunicipality here)
```{r}
diff_info <-diffman:::return_diff_info(list_z1 = area_z1_at_risk,threshold = 11,input_dt = input_dt)
diff_info
```
Now we can represent the at risk area with the draw situation function
First we have to create the geometry needed to represent the situation

Some functions to prepare geometry (municipalities and grid geometries)
```{r}
install.packages("btb")

get_centroid_carreau <- function(data, var_carreau){
  
  taille_carreau <- readr::parse_number(stringr::str_extract(data[[var_carreau]][1], "RES[0-9]*m"))
  centroides <- data %>%
    select(carreau = all_of(var_carreau)) %>%
    mutate(
      ll_coord_x = readr::parse_number(stringr::str_extract(carreau, "E[0-9]*$")),
      ll_coord_y = readr::parse_number(stringr::str_extract(carreau, "N[0-9]*")),
      centroid_x = ll_coord_x + taille_carreau/2,
      centroid_y = ll_coord_y + taille_carreau/2,
      crs = readr::parse_number(stringr::str_extract(carreau, "CRS[0-9]*"))
    )
  return(list(df = centroides, epsg=centroides$crs[1], taille=taille_carreau))
}

carreaux_to_polygon <- function(data, var_carreau){
  
  require(btb)
  
  centroides_l <- get_centroid_carreau(data, var_carreau)
  
  centroides_l$df %>%
    select(carreau, x=centroid_x, y=centroid_y) %>%
    btb::dfToGrid(sEPSG = centroides_l$epsg, iCellSize = centroides_l$taille)
  
}

communes <-sf::st_read("ext_data/commune_franceentiere_2021.shp")

```  

```{r}
l <- prepare_data(input_dt)
init_table <- l$intersecting_z2

situation_table <- init_table[z1 %in% area_z1_at_risk]
situation_table <- init_table[z2 %in% situation_table$z2]

liste_carreau <- situation_table$z2

polygone_carreau <-
  carreaux_to_polygon(data.frame(carreau = liste_carreau), var_carreau = "carreau") %>%
  sf::st_transform(crs = 4326)

geom_z1 <- communes %>%
  filter(code %in% unique(c(situation_table$z1))) %>%
  select(code) %>%
  rename(z1 = code)

geom_z2 <- polygone_carreau %>%
  rename(z2 = carreau) %>%
  select(-x,-y)
```

And then we can draw the situation on an interactive map
```{r}
draw_situation(situation_table,geom_z1,geom_z2,list_z1_to_color = area_z1_at_risk,threshold = 11)

toy_example_5 <- situation_table
usethis::use_data(toy_example_5)
```

Looking at the square at the intersection of the blue municapility and the orange one (those of the area at risk ) we recognize the square disoplaty by the return_diff_info function !
```{r}
diff_info
```
## Time calculation time on the biggest component

```{r}
compo[,.(nb_com = length(z1)),by ="id_comp"][rev(order(nb_com)),] %>% head()
list_z1_compo <- compo[id_comp == 1]$z1
input_dt <- data_rp[z1 %in% list_z1_compo]

s <- Sys.time()
l_area_z1_at_risk <- find_pbm_diff_tab(input_dt = input_dt,threshold = 11, save_intermediate_data_file ="res_grosse_compo" )
e <- Sys.time()

e-s
```
Time difference of 25.74686 mins, analysis of the results


## The whole risk extraction process 
```{r}
## test

# list_z1_compo <- compo[id_comp %in% seq(3:50),]$z1
# input_dt <- data_rp[z1 %in% list_z1_compo]
data_rp <- data.table(readRDS("data/data_rp.rds"))
input_dt <- data_rp

s <- Sys.time()
all_component_risk_extraction(
  input_dt,
  threshold = 11,
  max_agregate_size = 15,
  save_dir = "diff_info"
  )
e <- Sys.time()

e-s

global_diff_info <- read_diff_info("diff_info")

# à comparer avec le nombre de communes dzns chaque compo
global_diff_info[,.(n= length(z1)),by ="id_comp"][rev(order(n))]
```

```{r}
toy_example_7 <- data.table(
  z1 = c("M1","M1","M2","M2","M3","M3","M4","M4","M5","M6"),
  z2 = c("c1","c2","c1","c3","c2","c4","c3","c5","c4","c5"),
  nb_obs = c(10,25,30,30,40,50,20,19.5,20.3,10.9)
                            )
 # à méditer
 # }else{
 #    cl <- parallel::makeCluster(numCores)
 #    parallel::clusterExport(cl,c("one_component_risk_extraction",
 #                                 "find_pbm_diff_tab","agregate",
 #                                 "build_m_crois","copy","clean_init_dt",
 #                                 "prepare_data","agregate_one"))
 #    doParallel::registerDoParallel(cl)
 #    l_risk_compo <- foreach(i = seq_along(l_input_dt)) %dopar% extract_info_and_save(i)
 #  }
```

## Petit laius sur la stratégie de blanchiment pour le RP

diffman va en fait extraire des intesrsections carreaux X commlunes à risque. Mais blanchir systématiquement les carreeaux impliqués dans ces intersections n'apportera pas grand chose car la différenciation interne est toujours possible même si le carreau (ou les) chevauchant est blanchi (à méditer). En fait ce qu'il faut c'est s'assurer que l'attaquant ne puisse pas faire de différenciation du tout sur la zone extraite. Comme on ne touchera jamais aux totaux communaux il s'agit en fait de s'assurer que l'attaquant nbe soit pas en mesure de reconstruire le total des carreaux totalement inclus dans la commune  (dans le cas d'une différzenciation interner ou le total des carreaux totalement inclus ou partiellement (zone de carreaux recouvrante). Pour ce faire on veut plutôt blanchir des carreaux intérieurs à la commune. et il faut aussi s'assurer que  l'agregation ne soit pas retrouvable. C'est comme si on forcait des agregations blanchies dans griddy.. PAs simple..

## Tests diffman_tab on toy example (put that in test files) (what do we want to check ?)
```{r}
res1 <- find_pbm_diff_tab(toy_example_1,verbose = FALSE)
return_diff_info(list_z1 = res1[[1]] ,input_dt = toy_example_1,threshold = 11)

res2 <- find_pbm_diff_tab(toy_example_2,verbose = FALSE)
return_diff_info(list_z1 = res2[[1]] ,input_dt = toy_example_2,threshold = 11)

res3 <- find_pbm_diff_tab(toy_example_3,verbose = FALSE)
return_diff_info(list_z1 = res3[[1]] ,input_dt = toy_example_3,threshold = 11)

res4 <- find_pbm_diff_tab(toy_example_4,verbose = FALSE)
return_diff_info(list_z1 = res4[[1]] ,input_dt = toy_example_4,threshold = 11)

```
## TO DO :
-bmlanchir carreaux internes aux zones à risque en sortie de diff_info
-rajouter les carreaux interne en option dans draw situation, internal z2 area param  = TRUE
- commencer déjà par gérer en intra vérifier que dans chaque zone à risque il existe au moins un carreau totalement onclus blanchis et que la somme des carreaux blanchis faiaut au moins 11
- faire un exemple jouet pour illustrer la stratégie de blanchiement . une commune à 100 habitants avec 95 en carreaux inclus et 5 dans un carreau intersectant la commune et une autre.
- puis enfin penser à la remontée et comment gérer ça.
- pour griddy il faut pas gérer les carreaux blanchis par diffman en voulant les protéger mais juste s'en servir et ne pas chercher d'autres cases à blanchir si il en existe déjà une, c'est une sorte de statut non sensible des cases.
- ajouter les requirements dans description -> devtools:: check !!
-batterie de test !
- vignette CI etc.. faire un point ave +Julien
- AU 30 VS diffman regarder les notes une fois que c'est fait
- faire des statistiques de carreaux blanchis vs carreaux sous le seuil avec le scénario où on blanchit tous les carreaux au frontière (ou un seul ?) on casse le lien en faisant ça d'ailleurs réfléchir à ce que ça veut dire ?
- timer le taff sur composantes entiere ? sinon on boucle et parallelise sans verbose
- sinon faire du comp par composante
- analyse de sensibilité faire la fonction qui casse le graph (enleve les carreaux liants pourvoir) !!
- maîtriser la visibilité des fonctions exportabilités
- test 
- check

# à copier coller directement dans le terminal (en une fois ça marche pour récupérer les données)

mc cp s3/cguillo/commune_franceentiere_2021.dbf ext_data/commune_franceentiere_2021.dbf
mc cp s3/cguillo/commune_franceentiere_2021.fix ext_data/commune_franceentiere_2021.fix
mc cp s3/cguillo/commune_franceentiere_2021.prj ext_data/commune_franceentiere_2021.prj
mc cp s3/cguillo/commune_franceentiere_2021.shp ext_data/commune_franceentiere_2021.shp
mc cp s3/cguillo/commune_franceentiere_2021.shx ext_data/commune_franceentiere_2021.shx
mc cp s3/cguillo/data_rp.rds data/data_rp.rds