---
title: "Diffman tutorial"
author: "Clément G"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
    toc: true
    toc_depth: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r warning=FALSE,message=FALSE,echo = FALSE}
paquets <- c("data.table","btb","remotes","sf","igraph","Matrix","leaflet","dplyr","prettydoc")
# install.packages(paquets)
p <- lapply(paquets, function(p) suppressPackageStartupMessages(library(p, character.only = TRUE)))
# remotes::install_github("https://github.com/InseeFrLab/diffman-1")
```
## What can you do with diffman ?

```{r}

### Ce code sera amené à disparaitre, en fire une vignette ! ou bien un rmd !!!
#### Test sur données réelles 
data_rp <- data.table(readRDS("data/data_rp.rds"))
compo <- return_connected_components(data_rp)

compo[,.(nb_com = length(z1)),by ="id_comp"][rev(order(nb_com)),]

```

Here the R session explodes if  we put the whole data.frame in entry so we can work component by component thanks to the last function. the bigger contains more than 18000 municipalities !!
Here we will tests with id_comp 1232 !

```{r}
list_z1_compo <- compo[id_comp == 1232]$z1
input_dt <- data_rp[z1 %in% list_z1_compo]

l_area_z1_at_risk <- find_pbm_diff_tab(input_dt = input_dt,threshold = 11 )
length(l_area_z1_at_risk)

head(l_area_z1_at_risk,8)
```

299 union of elements of z1 at risk of differenciation here. let's look further one this risk area
```{r}
#lapply(l_area_z1_at_risk,length)
area_z1_at_risk <- l_area_z1_at_risk[[14]]
area_z1_at_risk


```

The return diff info function allows us to know ex&actly where the differencing issue occurs (which intersection square miunicipality here)
```{r}
diff_info <-return_diff_info(list_z1 = area_z1_at_risk,threshold = 11,input_dt)
diff_info
```
Now we can represent the at risk area with the draw situation function
First we have to create the geometry needed to represent the situation

Some functions to prepare geometry (municipalities and grid geometries)
```{r}
install.packages("btb")

get_centroid_carreau <- function(data, var_carreau){

  taille_carreau <- readr::parse_number(stringr::str_extract(data[[var_carreau]][1], "RES[0-9]*m"))
  centroides <- data %>%
    select(carreau = all_of(var_carreau)) %>%
    mutate(
      ll_coord_x = readr::parse_number(stringr::str_extract(carreau, "E[0-9]*$")),
      ll_coord_y = readr::parse_number(stringr::str_extract(carreau, "N[0-9]*")),
      centroid_x = ll_coord_x + taille_carreau/2,
      centroid_y = ll_coord_y + taille_carreau/2,
      crs = readr::parse_number(stringr::str_extract(carreau, "CRS[0-9]*"))
    )
  return(list(df = centroides, epsg=centroides$crs[1], taille=taille_carreau))
}

carreaux_to_polygon <- function(data, var_carreau){

  require(btb)

  centroides_l <- get_centroid_carreau(data, var_carreau)

  centroides_l$df %>%
    select(carreau, x=centroid_x, y=centroid_y) %>%
    btb::dfToGrid(sEPSG = centroides_l$epsg, iCellSize = centroides_l$taille)

}

communes <-st_read("data/commune_franceentiere_2021.shp")

```  
```{r}
l <- prepare_data(input_dt)
init_table <- l$intersecting_z2

situation_table <- init_table[z1 %in% area_z1_at_risk]
situation_table <- init_table[z2 %in% situation_table$z2]

liste_carreau <- situation_table$z2

polygone_carreau <-
  carreaux_to_polygon(data.frame(carreau = liste_carreau), var_carreau = "carreau") %>%
  st_transform(crs = 4326)

geom_z1 <- communes %>%
  filter(code %in% unique(c(situation_table$z1))) %>%
  select(code) %>%
  rename(z1 = code)

geom_z2 <- polygone_carreau %>%
  rename(z2 = carreau) %>%
  select(-x,-y)
```

 And then we can draw the situation on an interactive map
```{r}
draw_situation(situation_table,geom_z1,geom_z2,list_z1_to_color = area_z1_at_risk,threshold = 11)

toy_example_5 <- situation_table
usethis::use_data(toy_example_5)
```

Looking at the square at the intersection of the blue municapility and the orange one (those of the area at risk ) we recognize the square disoplaty by the return_diff_info function !
```{r}
diff_info
```
## Time calculation time on the biggest component

```{r}
compo[,.(nb_com = length(z1)),by ="id_comp"][rev(order(nb_com)),] %>% head()
list_z1_compo <- compo[id_comp == 1]$z1
input_dt <- data_rp[z1 %in% list_z1_compo]

s <- Sys.time()
l_area_z1_at_risk <- find_pbm_diff_tab(input_dt = input_dt,threshold = 11, save_intermediate_data_file ="res_grosse_compo" )
e <- Sys.time()

e-s
```
Time difference of 25.74686 mins, analysis of the results
```{r}
# mc cp res 

```
## Tests diffman_tab on toy example

```{r}

find_pbm_diff_tab(toy_example_1,verbose = FALSE)
find_pbm_diff_tab(toy_example_2,verbose = FALSE)
find_pbm_diff_tab(toy_example_3,verbose = FALSE)
find_pbm_diff_tab(toy_example_4,verbose = FALSE)

```
## TO DO :
- faire des statistiques de carreaux blanchis vs carreaux sous le seuil avec le scénario où on blanchit tous les carreaux au frontière (ou un seul ?) on casse le lien en faisant ça d'ailleurs réfléchir à ce que ça veut dire ?
- diffman ne passe pas sur l'ensemble des composantes ça crash, masi pas grave car ça passe sur la grosse seule donc pas besoin de pousser
- Maintenant faire des analyses de temps sur la grosse composante puis faire un travail sur les graphs sur une plus petite composante notamment regarder les points d'éclatement du graph, regarder les communes influentes très connectées pour lesquels quelques carreaux blanchis permettrainet de limiter le blanchiment
- timer le taff sur composantes entiere ? sinon on boucle et parallelise sans verbose
- sinon faire du comp par composante
- analyse de sensibilité faire la fonction qui casse le graph (enleve les carreaux liants pourvoir) !!
- faire une fonction de création de graph direct dans et l'utiliser dans return connected component
- montrer les toy example en equivalent graphique et faire les jeux d'application dessus
- maîtriser la visibilité des fonctions exportabilités
- test 
- ckeck
- toy example with associated picture
